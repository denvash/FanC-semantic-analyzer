%{
    #include "output.hpp"
    #include "parser.hpp"
    #include "types.hpp"
    #include <string>
    #include <iostream>
    #include <sstream>

    /* For debugging */
    extern char* yytext;
    extern int yylex();
    extern int yylineno;

    using namespace std;
    void debugPrint(char const*);
    void yyerror(char const*);
%}

%token VOID INT BYTE B BOOL TRUE FALSE RETURN IF WHILE BREAK CONTINUE SC COMMA LBRACE RBRACE ID NUM STRING

/* https://introcs.cs.princeton.edu/java/11precedence/ */
%right ASSIGN
%left OR
%left AND
%left EQ_RELOP
%nonassoc RELOP

%left PLUS_MINUS
%left MUL_DIV
%right NOT
%right RPAREN
%right LPAREN

%nonassoc NOELSE
%nonassoc ELSE

%%

Program :
                                    {
      debugPrint("Init program");
      init_program();
    }
    Funcs                           {
      debugPrint("Program Funcs");
    };

Funcs :
    %empty                          {}
    |   FuncDecl Funcs              {
      debugPrint("FuncDecl Funcs");
    };

FuncDecl:
    RetType ID LPAREN Formals RPAREN {
      debugPrint("FuncDecl RetType ID LPAREN Formals RPAREN");
      $2.e_type = $1.e_type;
      declare_function($2,$4);
      declare_formals($4);
    }
    OpenScope LBRACE Statements RBRACE CloseScope;

RetType:
    Type                            {
      $$ = $1;
    }
    |   VOID                        {
      debugPrint("RetType VOID");
      $$.e_type = TYPE_VOID;
    };

Formals:
    %empty                          {
      debugPrint("Formals Epsilon");
      $$.node = NULL;
    }
    | FormalsList                   {
      debugPrint("Formals FormalsList");
      $$ = $1;
    };

FormalsList:
    FormalDecl                      {
      debugPrint("FormalsList FormalDecl");
      $$.node = new FormalsList($1);
    }
    | FormalDecl COMMA FormalsList  {
      debugPrint("FormalsList FormalDecl COMMA FormalsList");
      $$.node = new FormalsList($1, $3);
    };

FormalDecl:
    Type ID                         {
      debugPrint("FormalDecl Type ID");
      $$.e_type = $1.e_type;
      $$.str_value = $2.str_value;
    };

Statements:
    Statement                       {
      debugPrint("Statements Statement");
    }
    | Statements Statement          {
      debugPrint("Statements Statements Statement");
    };

OpenScope:
    %empty                          {
      debugPrint("OpenScope");
      semantic_table.open_scope();
    };

CloseScope:
    %empty                          {
      debugPrint("CloseScope");
      close_scope();
    };

Statement:
    LBRACE Statements RBRACE                                    {
      debugPrint("Statement LBRACE Statements RBRACE");
      $$ = $2;
    }
    | Type ID SC                                                {
      debugPrint("Statement Type ID SC");
      $2.e_type = $1.e_type;
      declare_var($2,true);
    }
    | Type ID ASSIGN Exp SC                                     {
      debugPrint("Statement Type ID ASSIGN Exp SC");
      $2.e_type = $1.e_type;
      declare_var($2,true);
      assign_value($2,$4);
    }
    | ID ASSIGN Exp SC                                          {
      debugPrint("Statement ID ASSIGN Exp SC");
      assign_value($1,$3);
    }
    | Call SC                                                   {}
    | RETURN SC                                                 {
      debugPrint("Statement RETURN SC");
      return_value_check(TYPE_VOID);
    }
    | RETURN Exp SC                                             {
      debugPrint("Statement RETURN Exp SC");
      return_value_check($2.e_type);
    }
    | IF LPAREN Exp RPAREN Statement %prec NOELSE
    | IF LPAREN Exp RPAREN Statement ELSE Statement %prec ELSE  {}
    | WHILE LPAREN Exp RPAREN Statement %prec NOELSE            {}
    | WHILE LPAREN Exp RPAREN Statement ELSE Statement          {}
    | BREAK SC                                                  {}
    | CONTINUE SC                                               {};

Call:
    ID LPAREN ExpList RPAREN        {
      debugPrint("Call ID LPAREN ExpList RPAREN");
      $$.node = new Call($1,$3);
      $$.e_type = $$.node->get_type();
    }
    |   ID LPAREN RPAREN            {
      debugPrint("Call ID LPAREN RPAREN");
      $$.node = new Call($1);
      $$.i_value = $$.node->get_value();
      $$.e_type = $$.node->get_type();
    };

ExpList:
    Exp                             {
      $$.node = new ExpList($1);
      $$.i_value = $$.node->get_value();
      $$.e_type = $$.node->get_type();
    }
    | Exp COMMA ExpList             {
      $$.node = new ExpList($1, $3);
      $$.i_value = $$.node->get_value();
      $$.e_type = $$.node->get_type();
    };

Type:
    INT                             { $$.e_type = TYPE_INT; }
    |   BYTE                        { $$.e_type = TYPE_BYTE; }
    |   BOOL                        { $$.e_type = TYPE_BOOL; };

Exp:
    LPAREN Exp RPAREN               { $$ = $2; }
    | Exp PLUS_MINUS Exp            {
      debugPrint("Exp Exp PLUS_MINUS Exp");
      $$.node = new Exp($1, *$2.str_value, $3);
      $$.i_value = $$.node->get_value();
      $$.e_type = $$.node->get_type();
    }
    | Exp MUL_DIV Exp               {
      debugPrint("Exp Exp MUL_DIV Exp");
      $$.node = new Exp($1, *$2.str_value, $3);
      $$.i_value = $$.node->get_value();
      $$.e_type = $$.node->get_type();
    }
    | ID                            {
      debugPrint("Exp ID");
      $$.node = new Exp(*$1.str_value);
      $$.i_value = $$.node->get_value();
      $$.e_type = $$.node ->get_type();
    }
    | Call                          {
      debugPrint("Exp Call");
      $$ = $1;
    }
    | NUM                           {
      $$.e_type = TYPE_INT;
      $$.i_value = $1.i_value;
    }
    | NUM B                         {
      $$.e_type = TYPE_BYTE;
      $$.i_value = $1.i_value;
      if ($1.i_value > 255) {
        auto s = static_cast<ostringstream*>( &(ostringstream() << $1.i_value) )->str();
        error_handle(output::errorByteTooLarge, yylineno, s);
      }
    }
    | STRING                        {
      $$.e_type = TYPE_STRING;
      $$.i_value=1;
      $$.str_value = $1.str_value;
    }
    | TRUE                          {
      $$.e_type = TYPE_BOOL;
      $$.i_value= 1;
    }
    | FALSE                         {
      $$.e_type = TYPE_BOOL;
      $$.i_value= 0;
    }
    | NOT Exp                       {
      $$.e_type = TYPE_BOOL;
      $$.i_value = !$1.i_value;
    }
    | Exp AND Exp                   {
      $$.node = new Exp($1, "and", $3);
      $$.i_value = $$.node->get_value();
      $$.e_type = $$.node->get_type();
    }
    | Exp OR Exp                    {
      $$.node = new Exp($1, "or", $3);
      $$.i_value = $$.node->get_value();
      $$.e_type = $$.node->get_type();
    }
    | Exp EQ_RELOP Exp              {
      debugPrint("Exp EQ_RELOP Exp");
      $$.node = new Exp($1, *$2.str_value, $3);
      $$.i_value = $$.node->get_value();
      $$.e_type = $$.node->get_type();
    }
    | Exp RELOP Exp                 {
      debugPrint("Exp Exp RELOP Exp");
      $$.node = new Exp($1, *$2.str_value, $3);
      $$.i_value = $$.node->get_value();
      $$.e_type = $$.node->get_type();
    }
    ;

%%

int main() {
    yyparse();
    close_program();
    return 0;
}

void yyerror(char const* s) {
    output::errorSyn(yylineno);
    /* For debugging */
    cout << "syntax error from token: " << yytext << endl;
    exit(1);
}

void debugPrint(char const* rule){
    debug("semantic rule", rule);
}