%{
    #include "output.hpp"
    #include "semantic_table.hpp"
    #include <iostream>

    using namespace std;
    void yyerror(char const*);
    extern int yylex();
    extern int yylineno;
    /* For debugging */
    // extern char* yytext;


%}

%token VOID INT BYTE B BOOL TRUE FALSE RETURN IF WHILE BREAK CONTINUE SC COMMA LBRACE RBRACE ID NUM STRING

/* https://introcs.cs.princeton.edu/java/11precedence/ */
%right ASSIGN
%left OR
%left AND
%left EQ_RELOP
%nonassoc RELOP

%left PLUS_MINUS
%left MUL_DIV
%right NOT
%right RPAREN
%right LPAREN

%nonassoc NOELSE
%nonassoc ELSE
%%

Program :
    Funcs                           {}
;

Funcs :
    %empty                          {}
    |   FuncDecl Funcs              {}
;

FuncDecl:
    RetType ID LPAREN Formals RPAREN LBRACE NEW_FUNC Statements RBRACE {}
;

NEW_FUNC : %empty                   {
variable_t funcType;
funcType.is_func=true;
funcType.type=$1.e_type;
}


RetType:
    Type                            {}
    |   VOID                        {}
;

Formals:
    %empty                          {}
    | FormalsList                   {}
;

FormalsList:
    FormalDecl                      {$$.arguments_types.push($1.type)}
    | FormalDecl FORMAL_COMMA       {vector<TypeEnum> arguments_types;
                                    arguments_types.push($1.type);
                                    arguments_types.insert(arguments_types.end(),$2.arguments_types.begin(),$2.arguments_types.end());
                                     $$.arguments_types=arguments_types;}
;

FORMAL_COMMA: COMMA FormalsList  {$$.arguments_types=$2.arguments_types;}

INSERT_TYPE: %empty                              {}

FormalDecl:
    Type ID                         {$$.type=Type.e_type;}
;

Statements:
    Statement                       {}
    | Statements Statement          {}
;

Statement:
    LBRACE Statements RBRACE                                    {}
    | Type ID SC                                                {}
    | Type ID ASSIGN Exp SC                                     {}
    | ID ASSIGN Exp SC                                          {}
    | Call SC                                                   {}
    | RETURN SC                                                 {}
    | RETURN Exp SC                                             {}
    | IF LPAREN Exp RPAREN Statement %prec NOELSE               {}
    | IF LPAREN Exp RPAREN Statement ELSE Statement %prec ELSE  {}
    | WHILE LPAREN Exp RPAREN Statement %prec NOELSE            {}
    | WHILE LPAREN Exp RPAREN Statement ELSE Statement          {}
    | BREAK SC                                                  {}
    | CONTINUE SC                                               {}
;

Call:
    ID LPAREN ExpList RPAREN        {}
    |   ID LPAREN RPAREN            {}
;

ExpList:
    Exp                             {}
    | Exp COMMA ExpList             {}
;

Type:
    INT                             {}
    |   BYTE                        {}
    |   BOOL                        {}
;

Exp:
    LPAREN Exp RPAREN               {}
    | Exp PLUS_MINUS Exp            {}
    | Exp MUL_DIV Exp               {}
    | ID                            {}
    | Call                          {}
    | NUM                           {}
    | NUM B                         {}
    | STRING                        {}
    | TRUE                          {}
    | FALSE                         {}
    | NOT Exp                       {}
    | Exp AND Exp                   {}
    | Exp OR Exp                    {}
    | Exp EQ_RELOP Exp              {}
    | Exp RELOP Exp                 {}
;

%%

int main() {
   SemanticTable* st=new SemanticTable();
   st->initTable();
   yyparse();
    return 0;
}

void yyerror(char const* s) {
    output::errorSyn(yylineno);
    /* For debugging */
    /* cout << "syntax error from token: " << yytext << endl; */
    exit(1);
}