%{
    #include "output.hpp"
    #include "parser.hpp"
    #include "types.hpp"
    #include <string>
    #include <iostream>

    /* For debugging */
    extern char* yytext;
    extern int yylex();
    extern int yylineno;

    using namespace std;
    void debugPrint(char const*);
    void yyerror(char const*);
%}

%token VOID INT BYTE B BOOL TRUE FALSE RETURN IF WHILE BREAK CONTINUE SC COMMA LBRACE RBRACE ID NUM STRING

/* https://introcs.cs.princeton.edu/java/11precedence/ */
%right ASSIGN
%left OR
%left AND
%left EQ_RELOP
%nonassoc RELOP

%left PLUS_MINUS
%left MUL_DIV
%right NOT
%right RPAREN
%right LPAREN

%nonassoc NOELSE
%nonassoc ELSE

%%

Program :
    Funcs                           { init_program(); }
    ;

Funcs :
    %empty                          {}
    |   FuncDecl Funcs              {}
    ;

FuncDecl:
    RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE {
                                                                $2.e_type = $1.e_type;
                                                                declare_function($2,$4);
                                                              }
    ;

RetType:
    Type                            { $$ = $1; }
    |   VOID                        { debugPrint("RetType VOID"); $$.e_type = TYPE_VOID; }
    ;

Formals:
    %empty                          { $$.node = NULL; }
    | FormalsList                   { $$ = $1; }
    ;

FormalsList:
    FormalDecl                      {}
    | FormalDecl COMMA FormalsList  {}
    ;

FormalDecl:
    Type ID                         { $$.e_type = $1.e_type; $$.str_value = $2.str_value; }
    ;

Statements:
    Statement                       {}
    | Statements Statement          {}
    ;

OpenScope:
    %empty                          { semantic_table.open_scope(); }
    ;

CloseScope:
    %empty                          { close_scope(false); }
    ;

Statement:
    OpenScope LBRACE Statements RBRACE CloseScope               { $$ = $3; }
    | Type ID SC                                                {}
    | Type ID ASSIGN Exp SC                                     {}
    | ID ASSIGN Exp SC                                          {}
    | Call SC                                                   {}
    | RETURN SC                                                 {
                                                                  debugPrint("Statement RETURN SC");
                                                                  return_value(TYPE_VOID);
                                                                }
    | RETURN Exp SC                                             {}
    | IF LPAREN Exp RPAREN Statement %prec NOELSE               {}
    | IF LPAREN Exp RPAREN Statement ELSE Statement %prec ELSE  {}
    | WHILE LPAREN Exp RPAREN Statement %prec NOELSE            {}
    | WHILE LPAREN Exp RPAREN Statement ELSE Statement          {}
    | BREAK SC                                                  {}
    | CONTINUE SC                                               {}
;

Call:
    ID LPAREN ExpList RPAREN        {}
    |   ID LPAREN RPAREN            {}
;

ExpList:
    Exp                             {}
    | Exp COMMA ExpList             {}
;

Type:
    INT                             { $$.e_type = TYPE_INT; }
    |   BYTE                        { $$.e_type = TYPE_BYTE; }
    |   BOOL                        { $$.e_type = TYPE_BOOL; }
;

Exp:
    LPAREN Exp RPAREN               {}
    | Exp PLUS_MINUS Exp            {}
    | Exp MUL_DIV Exp               {}
    | ID                            {}
    | Call                          {}
    | NUM                           {}
    | NUM B                         {}
    | STRING                        {}
    | TRUE                          {}
    | FALSE                         {}
    | NOT Exp                       {}
    | Exp AND Exp                   {}
    | Exp OR Exp                    {}
    | Exp EQ_RELOP Exp              {}
    | Exp RELOP Exp                 {}
;

%%

int main() {
    yyparse();
    close_program();
    return 0;
}

void yyerror(char const* s) {
    output::errorSyn(yylineno);
    /* For debugging */
    cout << "syntax error from token: " << yytext << endl;
    exit(1);
}

void debugPrint(char const* rule){
    cout << "[debug] " << rule << endl;
}